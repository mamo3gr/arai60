## step 1

与えられた二分木に対し、level orderでtraverseしたときのノードの値を返す。ノードの数は最大2000.  
最初に発想したのは、幅優先で子ノードをキューに詰めていくと、level orderになる、ということ。  
現在の深さを記録しながら詰めたり取り出したりすれば、list of listのどこに入るかも分かる。

処理時間とメモリを見積もる。ノード数を `N` とすると、すべてのノードを訪れる必要があるので時間計算量は `O(N)`. ノードあたりの処理は (1) 値のappend, (2) 子ノードのキューへの追加、くらいなので、3ステップを仮定する。Pythonの処理能力を10万step/秒とすると、ノード数は最大2000なので、3 * 2000 / 10^6 [steps/sec] = 6ミリ秒くらいのオーダーを予想する。  
メモリについても `O(N)`. 具体的には、キューに最大でおよそ `N/2` の要素≒ノードが追加される。実際に追加するのは、ノードへの参照 (8bytes) と深さ (int, 28bytes). その他、最終的に返却するlist of listとして、`N` 個のintが必要。(8 + 28) * 2000 / 2 + 28 * 2000 = 92 KBくらいのオーダーを予想する。

実装する途中で、キューにノードだけ詰めて、深さは別に管理する（ループごとにインクリメントする）選択肢も浮かんだ。こちらの方が、キュー (deque) ではなくlistで十分だし、深さとループが対応していて見通しが良い。  
あと、`root` が `None` の場合をどこで捌くかの幅がある。非Noneならキューに入れる、とするか、先頭でNoneチェックをするかの2択だが、早期に返せる点で後者を選択した。

