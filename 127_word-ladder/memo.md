## step 1

`beginWord` から「1字だけを変更する」処理を繰り返して、`endWord` を目指す。辞書 `wordList` に含まれる単語のみを経由する。最短の変更数を調べる。単語長は最大10文字、辞書の語数は最大5000語。

まず思いついたのは、「現在の単語」と「`wordList` 内の使っていない単語」（とホップ数）をステートとして、1文字だけの変更の関係にある＝隣接した単語を幅優先探索していく、という方法。  
単語長を`L`, 辞書の語数を`W`とすると、ある2つの単語が隣接するか（相互に変換可能か）調べるには、時間計算量と空間計算量が `O(L)` かかる。  
現在のステートから遷移できるステートを列挙する時間計算量は、最悪ケースとしてすべてのステートが直列である場合を考えると `O(W^2)`. つまり全体で `O(L x W^2)`.  
空間計算量が大きそう。ステートあたり、(1) 単語 (str) ひとつと (2) `W` 個の文字列、(3) ホップ数 (int) を保持することになる。(2) が支配的なのでこれだけ考えることにすると、辞書へのインデックス (int) を持つとしても、ステートひとつで5000個のint, つまり5000 x 28 bytes/int = 0.14 MBかかる。すべてのステートが幅優先探索の1階層に含まれるとすると `O(W^2)`. 0.14 * 5000 = 700MB くらいかかる。現代の計算機のメモリに載らないことはないがもっと削減できそう。ちなみにダメ元で実装してみたがMemory Limits Exceededだった。

「`wordList` 内の使っていない単語」x ステート数がネック。ステートごとに残りの単語を保持しなくても処理可能ではないか。単語をノード、隣接する単語の間をエッジとすると、最短経路問題に帰着できることを発想する＝Dijkstra法で解ける。エッジの長さはすべて1なので、スタートのノードに隣接するノードを起点として（ホップ数=1）、いずれかのノードに隣接するノードを列挙してホップ数=2をセット、今度はそれらのノードを起点に隣接するノードを探す…としていけばよい。これだと時間計算量は前述の解法と変わらないものの、空間計算量は `O(W)` にできる。すなわち、起点にするノードのインデックスを保持するのに高々 `W` 個のintと、ノードごとにホップ数を記録する長さ `W` の配列である。  
ちなみに、反対に `endWord` から探索を始めてみた。というのも、`wordList` に `endWord` が含まれない場合は探索なしに結果を返せるし、本処理のループを書くうえで `wordList` に入っている単語を起点にできるのでコードが比較的スッキリすると考えたからだ（`beginWord`は`wordList`に含まれない）。

コードはあんまりまとまっていないが、何とかテストをパス。ちゃんと考えてパスまでたどり着けたのはちょっと達成感がある（とはいえこの練習としてはこれで3割程度の達成率）。

