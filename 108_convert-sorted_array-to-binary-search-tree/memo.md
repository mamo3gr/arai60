## step 1

ソート済みの配列をBinary Search Tree (BST, 二分探索木) に変換する問題。  
おさらいしておくと、BSTはいずれのノードにおいても、左 <= 親 <= 右という関係になっている。  
ちなみにheight-balancedであることも制約になっている。

>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

直感的に、与えられた配列のちょうど真ん中が、最終的な根になりそう（厳密な証明が思いつかないが、後で考えてみよう…）。で、この左右の配列をそれぞれ再帰して子ノードとして繋げれば良さそう。  
これをキューを使ったループにも変換できそうだが、再帰のほうがスッキリ書ける。前者はstep2で書いてみよう。  
配列は最長で10^4. したがって、できる木の深さはlog2(10^4) = 13.28くらいで、スタックオーバーフローのリスクは低い。

処理時間とメモリ使用量を見積もる。  
この関数の1コールにつき1ノードが生成される。配列の要素数だけコールが必要なので、配列の長さを `N` とすると `O(N)`. ノード生成あたり5ステップと仮定すると、5 * 10^4 / 10^6 [steps/sec] = 0.05秒 = 50ミリ秒くらいのオーダーと予想する。  
成果物となるノードはintひとつとポインタ2つなので、28 + 8*2 = 44 bytes くらいかかる。44 * 10^4 = 440 KBのオーダーと予想。

配列の長さが2または3のときをキャッチすることで再帰回数が減らせるが、関数そのもののシンプルさを優先する。

