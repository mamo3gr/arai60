## step 1

2つの数列のintersectionを返す。setのメソッドとして提供されているが、出題の意図はなんだろう。

## step 2

たぶん「じゃあintersectionをどう実装する？」みたいな話なんだろうな。

どちらかの配列をsetにする。時間計算量 `O(N1)`, 空間計算量 `O(M1)`. ただし `M1` は `nums1` に含まれるユニークな数字の数。  
もう片方の配列のそれぞれ数字について、setに含まれていれば答えのset（以降answer\_set）にaddする。`O(N2)` でできる。answer_setは `O(M)` の空間が必要（`M` は共通するユニークな数字の数）。

総合すると、時間計算量は `O(N1 + N2)`, 空間計算量は `O(M1 + M)`. 先にsetにするのは、短い方の配列がいいんだな。極端に差が無いと大差ないだろうけど。

### 他の人のコード

https://github.com/Yuto729/LeetCode_arai60/blob/e8c9aeacce92b9fbf35bc4ac02c9beade99460a3/intersection-of-two-arrays/main.md

https://github.com/katataku/leetcode/pull/12#discussion_r1893968021

>片方がとても大きくて、片方がとても小さいときには、大きい方を set にするのは大変じゃないでしょうか、特に大きいほう が sort 済みのときにはどうしますか。

ソート済みのケースも考えてみるか。

>長いほうがソートされている場合, 長い方のリストをイテレーションするより二分探索で見つけるほうが良い.

なるほど。`nums1`が短い方として、`N1`個の数字それぞれについて、`log N2` で二分探索できる。

>他、両方ソートされていてとても大きければ、マージソートの変形のように書くと思います.

これは書いてみよう。答えの配列をlistで持つと、共有する数を見つけた後のポインタの処理がちょっと面倒になる（重複してappendしないためにポインタを進める必要がある）。

https://github.com/docto-rin/leetcode/pull/13/files#r2416241698

>公式にはエラーの起こりにくさと読みやすさの観点から&よりintersectionが推奨されていますね

ほうほう。

## step 3

幅出しは解き方だけじゃなく問題（条件）もあるのね。勉強になりました。
