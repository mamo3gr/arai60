## step 1

与えられた二分木に対し、level orderでtraverseしたときのノードの値を返す。ノードの数は最大2000.  
最初に発想したのは、幅優先で子ノードをキューに詰めていくと、level orderになる、ということ。  
現在の深さを記録しながら詰めたり取り出したりすれば、list of listのどこに入るかも分かる。

処理時間とメモリを見積もる。ノード数を `N` とすると、すべてのノードを訪れる必要があるので時間計算量は `O(N)`. ノードあたりの処理は (1) 値のappend, (2) 子ノードのキューへの追加、くらいなので、3ステップを仮定する。Pythonの処理能力を10万step/秒とすると、ノード数は最大2000なので、3 * 2000 / 10^6 [steps/sec] = 6ミリ秒くらいのオーダーを予想する。  
メモリについても `O(N)`. 具体的には、キューに最大でおよそ `N/2` の要素≒ノードが追加される。実際に追加するのは、ノードへの参照 (8bytes) と深さ (int, 28bytes). その他、最終的に返却するlist of listとして、`N` 個のintが必要。(8 + 28) * 2000 / 2 + 28 * 2000 = 92 KBくらいのオーダーを予想する。

実装する途中で、キューにノードだけ詰めて、深さは別に管理する（ループごとにインクリメントする）選択肢も浮かんだ。こちらの方が、キュー (deque) ではなくlistで十分だし、深さとループが対応していて見通しが良い。  
あと、`root` が `None` の場合をどこで捌くかの幅がある。非Noneならキューに入れる、とするか、先頭でNoneチェックをするかの2択だが、早期に返せる点で後者を選択した。

## step 2

まずは再帰でも書いてみる。  
いま処理するノードの深さを渡してやり、かつ左の子ノードから再帰するようにすれば、それぞれの深さに対して左から右の順で値を入れられそう。  
ヘルパー関数の良い名前が思いつかない。`traverse` にしてみたものの、値をappendするニュアンスも足したかった。  
ヘルパー関数に、最終的な戻り値 `values` を与えて更新後の `values` を返させる、という選択肢も思いついたが、https://github.com/mamo3gr/arai60/pull/18#discussion_r2665104757 の議論から避けるようにした。

### 他の人のコード

#### https://github.com/plushn/SWE-Arai60/pull/26

listを使ったBFS. 途中のステップでは、深さごとの処理を関数に括りだしているが、最終的にベタ書きにしている（自分もその方が好み）。  
深さごとのノード数が分かっているので、`[0] * len(nodes)` のように先にlistを確保している。たしかにこちらの方が途中でlistの拡張をしないぶん効率的だが、listの要素を `i` で狙いにいくのはあんまりPythonっぽくない書き方に感じる。

本筋ではないが、None判定を `is None` あるいは `is not None` と書くことに（自分として）している、ということを思い出した。※Googleスタイルガイドに従うつもりで

#### https://github.com/naoto-iwase/leetcode/pull/30

listを使ったBFS (step 3). 自分のstep1とほぼ一緒。ノードを入れておく `current_level`, `next_level` は分かりやすい。

#### https://github.com/nanae772/leetcode-arai60/pull/26

二重の内包表記を使うことで、次の深さのノードをリストアップできる。可読性の面から避けたい気持ちになる。

```python
[child for node in nodes for child in (node.left, node.right) if child]
```

>自分でフォローアップ質問を考えてBFS, DFSそれぞれのメモリ使用量の違いの深掘りなどをしていてとても勉強になった。  
>DFSだと縦に掘っていくので平衡二分木のような高さが低い場合に効率的で、  
>BFSは木に偏りがある場合や全ての木がメモリに乗らず各レベルで取得しなければならない場合などに有効という理解をした。

問題自体はパスして、コードも整えられるようになりつつあるので、こういうフォローアップも考えられるようになりたい。

内包表記を使えば、ループを2重から1重にできる (step2-bfs.py).

変数に使う前置詞、自分は `_for_` かなと思っていたが `_by_` が多い。Geminiに聞いた感じ、英語的にも後者のほうが正確らしい。

### コメント集

https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0

>「level が大きくて nodes_ordered_by_level が足りない場合、足りるように拡張します。そして、拡張した場所に書き込みます。」(読んでいくと、あとから、足りないことがあったとしても1段であることが他のところから分かる。)
>
>「level が大きくて nodes_ordered_by_level が足りない場合、1段だけ拡張します。そして、level 番目に書き込みます。(書き込めなかったら IndexError が投げられます。)」(読んでいくと、1段だけしか拡張しなくても、level 番目が準備されているので例外はないことが分かる。)
>
>というふうに読めます。どっちが読み手にとっていいですか。
>
>1段だけしか拡張しなくても例外が投げられることがないことに気がつくパズルを解かせる必要ないですよね。そうすると、下にするならば、コメント1行付けておいて、くらいの感覚です。

これ自分でも思った（『1段だけしか拡張しなくても例外が投げられることがない』か？）。  
最後に一手間かかるけど`defaultdict`使う、とかもアリかのかな。

https://discord.com/channels/1084280443945353267/1200089668901937312/1211248049884499988

## step 3

再帰よりlistを使った実装のほうが、脳内でシミュレートしやすく好み。  
list of listで入れるべき場所ができているかを確認するのは手間なので、深さごとにループしてlistをappendする方が好み。  
子ノードを追加する内包表記が二重になるので避けたい。となると、ノードごとにループを回す。  
子ノードは2つしか無いので、ここもベタに書く。  
Noneチェックは先に（リストへ追加する前に）やったほうがシンプルに思う。

再帰でも書いてみる。  
個人的には、`while len(values_by_level) <= level` から、`values_by_level[level]` が `IndexError` にならないように、という意図を読み取るのに時間がかかってしまう（いっそ `IndexError` しないことを条件に書きたい）。また、この再帰の呼び方で本当にlevel orderになるのかちょっと考えてしまう。これらの理由から、書いてみたものの再帰は避けたい気持ちになる。

途中で、上記がノードごとの再帰であることに気がつく。深さごとに再帰するパターンも書いてみた。こっちははじめのBFSにちょうど対応する。

