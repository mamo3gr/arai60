## step 1

与えられた数列から、足して `target` になる2つの数を返す。数列長は最大10^4.
最もシンプルには、すべての組み合わせについて和が `target` になるか調べる。数列長をNとすると `O(N^2)` になる。Pythonの速度目安が10^6ステップ/秒とすると (10^4)^2 / 10^6 = 100秒くらいのオーダーでかかる。もっと速くできそう。

`nums = [2,7,11,15], target = 9` という問題のとき、`2` が答えになるには `nums` のどこかに `7` が存在していればいい。`nums` を頭から見ていく。相方になる数が入っていたら終了。そうでなければ、ハッシュマップに自身を入れて次へ。

インデックスを返す必要があるので、ハッシュマップとしてkey=数, value=インデックスというdictを使う。

時間計算量は `O(N)` になる。最悪ケースは `nums` の最初と最後の要素がペアの場合。 10^4 / 10^6 = 0.01秒オーダー。  
空間計算量は `O(N)`. dictのオーバーヘッドは無視して、keyとvalueでそれぞれint（28バイト）使うとすると、2 * 28 bytes * 10^4 = 560 KBくらい。ハッシュテーブルの大きさの見積もりが難しいが、かかっても1 MBに収まるのでは。

## step 2

`seen` は `num_to_index` がいいかな。見た (seen) 数字を入れていくのは処理を読んでいれば分かるので。

### 他の人のコード

https://github.com/komdoroid/arai60/pull/1/files#r2553941063

ハッシュマップの命名、`num_to_index` は常識の範囲内っぽくて安心。

https://github.com/komdoroid/arai60/blob/d0a1cc8751578bbe84b2f0777768149ea1bd31ce/TwoSum/step3.py

- ループは `for i in range(len(nums))` よりも `enumerate(nums)` を使うほうがスッキリしていて好み。本文でも `nums[i]` と引く必要がなくなるし。
- `diff` も悪くないけど、どうしてもGitなどの「差分」みたいなニュアンスも想起してしまう。

https://github.com/MasukagamiHinata/Arai60/blob/cf4a54e17c831937799d2368d6f33df8f4ec8123/1.%20Two%20Sum.py

実務上は「解なし」の可能性があって、`raise` する。親切。  
複数見つかる可能性もあるから、唯一のペアを返すのかを確認するなら、見つかったペアを保持しつつループを続けるんだろうな。

https://github.com/Yuto729/LeetCode_arai60/blob/9ac6cebe31306a24430c5d963fc5757218cf4569/1.TwoSum/two_sum.py

すっ飛ばしてしまったが、最初の走査で辞書にインデックスを入れていって、次の走査で補数を見つける、というパターンもある。`O(N)` だが倍かかる。

https://github.com/tNita/arai60/blob/1ca3b6b52e57f3c4889832dca54641a9ca02ac27/1-two-sum/memo-after-reviewed.md

2ポインタ法というのがあるんだ。面白い。  
最初に数列をソートして（`O(N log N)`）、左端と右端を指すポインタを用意して探索開始。和がtargetより小さいなら、左端のポインタを右にひとつ動かす。targetより大きいなら、右端のポインタを左に動かす。最悪(N/2-1)回繰り返す。つまり `O(N)`.  
ソート済みの数列（ともとのインデックス）を持っておくのに `O(N)`。  
オーダーだけ見るとハッシュマップを使った解法と大差ない。

さらに別な方法として、数列をソートした上で、それぞれの要素に対して補数を二分探索で見つける、というのもある。ソートとこの探索で時間計算量は `O(N log N)`, 空間計算量は `O(N)`.

### コメント集

https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.z4zz4wpn0zz0

>まず、この問題、手でやるならどうしますか？

プログラムが書けるとbrute-forceがちになっちゃう。

## step 3

数列の長さが足りない場合と、ペアが見つからない場合でraiseするようにした。  
正解が複数ある場合への対応は過度に冗長になりそうなのでパス。やるなら  

* インデックス `(i, j)` を `i < j` を満たすようにソートしてから
* setに入れる
* 最後に `len(set) == 1` を確かめて中身を返す。これを満たさないならraiseする。

あるいは、仕様として「見つかった最初のペアをひとつだけ返す」にするとか。

