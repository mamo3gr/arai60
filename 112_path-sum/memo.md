## step 1

二分木と `targetSum` が与えられて、和がそれに等しい root-to-leaf path を持っているかどうかを判定する問題。ノード数は最大5000で、値は負の数もありえる。

rootからそれまでの和を覚えながら辿っていき、leafに着いたときに `targetSum` と等しいか判定すれば良さそう。再帰でもキューでも書けるが、再帰がぴったり当てはまりそうに思うので、まずは再帰で書いてみる。早く返せるかどうかは、条件に当てはまるleaf nodeの深さに依存しているので、一般には再帰とキューのどちらが優れているかは言えなさそう。

時間計算量は、ノード数を `N` とすると最良で `O(log N)`（最初のleafで条件を満たす）、最悪で `O(N)`. 処理としては (1) `node.val` を覚えている和に足す、(2) leafか判定する、(3) 子ノードに対して再帰する、くらいなので3ステップと仮定すると、3 * 5000 / 10^6 [steps/sec] = 15ミリ秒くらいのオーダーを予想する。  
使うメモリは、子ノードを調べるときに、スタックが高々 `log N` 必要。log(5000) = 16.6くらいで、Pythonの一般的な再帰呼び出し上限は1000なので、かなり余裕がある。

ノード数は0があり得るので、`root is None` の判定が必要。このロジックにまかせて、子ノードが `None` かどうかを気にせず再帰しちゃう（関数本体の短さを優先）。

