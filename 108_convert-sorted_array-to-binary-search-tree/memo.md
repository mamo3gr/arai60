## step 1

ソート済みの配列をBinary Search Tree (BST, 二分探索木) に変換する問題。  
おさらいしておくと、BSTはいずれのノードにおいても、左 <= 親 <= 右という関係になっている。  
ちなみにheight-balancedであることも制約になっている。

>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

直感的に、与えられた配列のちょうど真ん中が、最終的な根になりそう（厳密な証明が思いつかないが、平衡にするには、根を取ったあとの左右の要素数を揃える必要がある。後で考えてみよう…）。で、この左右の配列をそれぞれ再帰して子ノードとして繋げれば良さそう。  
これをキューを使ったループにも変換できそうだが、再帰のほうがスッキリ書ける。前者はstep2で書いてみよう。  
配列は最長で10^4. したがって、できる木の深さはlog2(10^4) = 13.28くらいで、スタックオーバーフローのリスクは低い。

処理時間とメモリ使用量を見積もる。  
この関数の1コールにつき1ノードが生成される。配列の要素数だけコールが必要なので、配列の長さを `N` とすると `O(N)`. ノード生成あたり5ステップと仮定すると、5 * 10^4 / 10^6 [steps/sec] = 0.05秒 = 50ミリ秒くらいのオーダーと予想する。  
成果物となるノードはintひとつとポインタ2つなので、28 + 8*2 = 44 bytes くらいかかる。44 * 10^4 = 440 KBのオーダーと予想。

配列の長さが2または3のときをキャッチすることで再帰回数が減らせるが、関数そのもののシンプルさを優先する。

## step 2

キュー (deque) を使った実装も書いてみる。途中でスタック (list) でも良いことに気が付き、スタックに変更（`collections`パッケージのインポートが不要なため）。違いは木が上からできるか、下からできるか。

書いていて気が付いたが、配列そのものをスタックに積むよりも、範囲＝もとの配列の開始・終了インデックスを持つほうが省メモリだ（部分配列が都度コピーされる）。再帰でも同じ考え方ができそう。デメリット…というか気をつける点としては、インデックスの扱いでバグを埋め込むリスクが上がること。  
配列の範囲の終点を扱うのに、開区間と閉区間の方がある（始点は閉区間でいいだろう）。Pythonのインデックスに従うなら開区間だが、閉区間の方が（個人的には）扱いやすくバグのリスクが減らせそう。「リーダブルコードで」、開区間なら `begin, end`, 閉区間なら `start, last` を使う、という命名を思い出す。→書いてみたら「中央の要素を抜いた、配列の左右がそれぞれ存在するかどうか」の分岐条件が違うだけみたいだった。

### 他の人のコード

#### https://github.com/Shoichifunyu/shofun/pull/18

再帰での実装 (step3). インデックスには `left`, `right`, `mid` を使っている。Geminiによると `mid` は `middle` の略称で、`center` はどちらかというと幾何的な中央・中心を指すことが多いらしい。へえー。

#### https://github.com/plushn/SWE-Arai60/pull/24

再帰での実装 (step1). インデックスの範囲を気にせず再帰しちゃって、`left > right` なら `None` を返すようにしている。こうすると範囲に基づく再帰する・しないの判定がなくなるのでコードはシンプルになる。一方で `None` を返すための再帰呼び出しが増える。また、`left == right` なら `TreeNode` を返すだけで終わり（再帰呼び出ししない）、というパターンもある。

キューでの実装 (step2). `(ノードをつなぐ親、開始、終了、左右のどちらにつなぐか)` をキューに入れる。自分の場合は、ノードを作ってしまって、`(値を設定するノード、開始、終了)` を引き継いでいた。

#### https://github.com/naoto-iwase/leetcode/pull/23

キューでの実装 (step2). `start, end` からノードを作る関数、`start, end` から左右の範囲に分割する関数をそれぞれ定義しており、メインルーチンがすっきりして読みやすい。  
キューには `(接続先の親, 左の区間, 右の区間)` を引き継ぐ。番兵を置いているが不要にも見える。

### コメント集

https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.9s63li7jygve

C++だとポインタのポインタが使えるので、Pythonよりもさらに柔軟に書ける。  
一方でメモリリークのリスクもある。

## step 3

実際に書くなら再帰にすると思う。
比較的短いコードだけど `_index` は付けたほうが親切。  
ロジックのシンプルさを優先して、子ノードができるかどうかはひとまず再帰して、再帰先でNoneを返す。

