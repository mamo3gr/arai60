## step 1

単語の列が与えられるので、アナグラムごとにグルーピングして返す。  
例えばnatとtanはアナグラムの関係になっているが、ソートして一致する、あるいは文字の出現数のヒストグラムが一致することと同値である。これらをkey、単語のリストをvalueにしたdict（ハッシュマップ）に詰めていけばよい。

単語はアルファベットの小文字からなり、最長で100文字。つまりヒストグラムは26次元になる。単語数は最大で10^4個。単語数を `N`, 単語長を `W` として時間計算量と空間計算量を見積もってみる。

### ソートする場合

まずは時間計算量。N個の単語それぞれについて、単語のソートに `O(W log W)`, ハッシュマップを引いてlistへ追加するのはどちらも `O(1)`. できたハッシュマップから答えの形へ変換するのに `O(N)` かかる。つまり全体で `O(NW log W)`.

空間計算量は `O(N)`. 1文字1バイトとして単語あたり100バイト * N個で100 bytes * 10^4 = 1MB. ハッシュマップのkeyも持つ必要があるが高々倍（すべての単語がユニークの場合）。

### ヒストグラムを使う場合

時間計算量は、単語からヒストグラムを作るのに `O(W)`. それ以外はソートする場合と変わらない。したがって `O(NW)`.

空間計算量は `O(N)`. 26次元のヒストグラムは、intあたり28bytes * 26 = 728bytes. これを最大N個持つことになる。728 bytes * 10^4 = 7.28MB. ソートの場合とオーダーは変わらない（がちょっと多い）。

### 意思決定

ソートにする。時間計算量は単語数が支配的だろうから、ヒストグラムを作るのがソートよりも速くても、その寄与は小さいことが予想される。空間計算量のオーダーは変わらない（たぶんソートの場合の法が多少有利）。コードの簡潔さはソートの方が有利そうで、ここが個人的に大きい（ヒストグラムをタプルで作って…みたいなのが面倒）。
